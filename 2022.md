# Вступительная лабораторная работа

Лабораторная работа Тинькофф для смены в "Сириусе" от феварля 2022

Привет!

Мы очень рады, что вы успешно справились с тестом и решили выполнить вступительную лабораторную работу. Ее цель — выяснить, насколько хорошо вы сможете написать небольшое приложение по подробной инструкции.

Авторы наиболее качественных и полных работ будут зачислены на курс.

**Важно!** Предупреждаем, что публикация материалов — этого документа, инструкций к домашним заданиям, исходного кода работ, скриншотов и т.д. — запрещено. Мы хотим, чтобы и в будущем места на курсе доставались самым мотивированным и талантливым кандидатам — а не тем, кто смог нагуглить материалы прошлого потока.

## Работа с Git и GitHub

На курсе — как и в реальной работе разработчика — мы будем постоянно работать с системой контроля версий Git. С ней удобно отслеживать изменения в коде и отменять неудачные, а также синхронизировать общую кодовую базу между всеми участниками команды.

Домашние работы нужно загружать на GitHub. Обратите внимание, что это обязательное требование курса: мы не принимаем материалы на других сайтах (GitLab, Bitbucket), в виде ZIP-архивов, на Google Drive и т.д. Впрочем, если вы читаете этот текст, значит аккаунт у вас уже есть.

В программе курса есть много важных тем, поэтому мы не будем отдельно разбирать работу с Git и GitHub. Если вы чувствуете себя неуверенно в этих вопросах, рекомендуем почитать статьи в интернете.

## Задача

В этой лабораторной работе вам предлагается создать приложение, которое будет запрашивать из интернета и отображать на экране актуальную информацию об акциях выбранной пользователем компании:

* название компании;
* обозначение бумаги на бирже (тикер): например, `AAPL` или `TCS`;
* текущую цену;
* изменение цены за период.

## Подготовка

Когда вы перешли по ссылке на учебном портале, специально для вас создался репозиторий с названием вида `intro-lab-annapetrova`. Внутри репозитория есть файл с текстом задания (сейчас вы как раз читаете его). В ходе работы вы будете создавать новые файлы, и их нужно добавлять в этот же репозиторий.

Пока ваш репозиторий существует только на серверах GitHub. Чтобы с ним было возможно работать, его нужно *клонировать*. Задание нужно выполнять в папке репозитория.

Когда вы закончите лабораторную, у вас должен получиться репозиторий с добавленными в него файлами проекта (приложения). Именно в таком виде преподаватели ожидают получить работы. Затем они клонируют ваш репозиторий на свои компьютеры и запустят проект. Закончив работу и загрузив ее в репозиторий, убедитесь, что все работает. Для этого можно повторно клонировать репозиторий в отдельную папку и запустить приложение оттуда.

## Источник данных

Наше приложение будет отправлять [HTTP-запрос](https://ru.wikipedia.org/wiki/HTTP) к серверу и в ответ получать нужные данные (информацию о ценной бумаге). Первый же результат в поиске Google по фразе “stock api” вернул нам простой сервис, подходящий для нашей задачи https://iexcloud.io/docs/api/

У этого сервиса есть метод [`/stock/{symbol}/quote`](https://cloud.iexapis.com/stable/stock/{symbol}/quote), который возвращает JSON-объект с информацией по акции.

Например для компании Apple, полный запрос должен выглядеть так https://cloud.iexapis.com/stable/stock/aapl/quote?&token=pk_4335b7641e304f6e8ef89cfe43a99cb4 (переменную token потребуется завести самим через личный кабинет сервиса). 

Из ответа-то мы и возьмем название компании, текущую стоимость акции и изменение цены:
```
{
  "symbol": "AAPL",
  "companyName": "Apple Inc.",
  "primaryExchange": "Nasdaq Global Select",
  "sector": "Technology",
  "calculationPrice": "tops",
  "open": 154,
  "openTime": 1506605400394,
  "close": 153.28,
  "closeTime": 1506605400394,
  "high": 154.80,
  "low": 153.25,
  "latestPrice": 158.73,
}
```

  `Если по какой-то причине этот сервис вам не понравился, либо работа с ним не заладилась, вы можете использовать любой другой сервис для получения нужных нам данных, либо попробовать использовать https://sandbox.iexapis.com, переключив switcher sandbox view в состояние ON в личном кабинете iexcloud.io.`

## Создание проекта в Xcode

Разработка iOS-приложений обычно происходит в [Xcode](https://developer.apple.com/xcode/). Именно эту программу мы будем использовать в нашем курсе. Xcode можно загрузить бесплатно из [Mac App Store](https://apps.apple.com/us/app/xcode/id497799835?mt=12) или из [раздела загрузок на портале разработчиков](https://developer.apple.com/download/all/) (потребуется бесплатный аккаунт разработчика). Рекомендуем установить последнюю релизную версию.

Итак, мы запустили Xcode и готовы создать новый проект. Выбираем шаблон iOS-приложения с единственным экраном — Single View App:

![](https://user-images.githubusercontent.com/4648742/131654251-8ca5222a-f5c5-44f7-8e3b-dca56c5acd56.png)

Далее указываем название продукта, команду разработки (если есть) и остальные поля (их назначение рекомендуем погуглить). Убедитесь, что в качестве языка выбран Swift, а в качестве устройства — iPhone (iPad выбирать не нужно).

![](https://user-images.githubusercontent.com/4648742/131654298-739bf2a6-b601-4550-968c-4b2a94b1a5d7.png)

При сохранении проекта обратите внимание на чекбокс “Create Git repository on my Mac.” Мы рекомендуем всегда отмечать его — даже если над проектом будете работать только вы. Прямо сейчас отмечать чекбокс не нужно, поскольку репозиторий у нас уже есть. В окне выбора локации выберите клонированный ранее репозиторий.

![](https://user-images.githubusercontent.com/4648742/131654465-e3d8d66f-e678-4ff4-b518-3b63cf4413b5.png)

Мы создали проект по шаблону и видим несколько автоматически созданных файлов в <abbr title="панель в левой части окна">проектном навигаторе</abbr> (если он не отображается, нажмите <kbd>⌘</kbd> + <kbd>1</kbd>).

(На первый взгляд Xcode кажется большой и сложной программой, но со временем вы в ней обязательно разберетесь! Посмотрите [руководство](https://developer.apple.com/library/archive/documentation/ToolsLanguages/Conceptual/Xcode_Overview/) и [обзор основных элементов интерфейса](https://developer.apple.com/library/archive/documentation/ToolsLanguages/Conceptual/Xcode_Overview/TheWorkspaceWindow.html#//apple_ref/doc/uid/TP40010215-CH25-SW1), чтобы начать ориентироваться быстрее.)

## Сохраняем промежуточные результаты в Git

По мере выполнения работы рекомендуем сохранять изменения — *комитить* их — в Git. Когда вы отметили чекбокс “Create Git repository on my Mac” при создании проекта, Xcode автоматически закомитил созданные файлы в репозиторий. Последующие изменения нужно комитить вручную. Как часто делать это, решать вам — количество комитов и размер каждого не ограничены.

Чтобы открыть окно создания комита, нажмите <kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>C</kbd>. Слева вы увидите список измененных файлов, а справа — сравнение версий до и после изменения. Внизу вам нужно ввести сообщение комита — обычно в нем кратко описывают проделанную работу. Введите сообщение, но пока не спешите нажимать кнопку Commit Changes.

Если просто создать комит, он будет доступен только в *локальном* репозитории на вашем компьютере — преподаватели его не увидят. Чтобы комит попал на GitHub, его еще нужно *запушить*. Xcode сделает это автоматически, если вы поставите соответствующую галочку под полем для сообщения.

Вы можете использовать и другой Git-клиент — например, [GitHub Desktop](https://desktop.github.com/).

## Подготовка интерфейса

Открываем в проектном навигаторе файл `Main.storyboard`. Этот файл содержит в себе XML-код, который описывает визуальные элементы приложения, их конфигурацию и взаимодействие. Сториборд чаще всего используется для удобства: описывать интерфейс можно и кодом, но это занимает больше времени. В нашем сториборде уже присутствует пустой вью-контроллер. 

`Вы можете верстать и из кода, если так будет удобнее (SwiftUI использовать нельзя).`

![](https://user-images.githubusercontent.com/4648742/131658813-b29fa4ba-00cf-4efe-9cd1-1f82ba5eed3c.png)

[View Controller](https://developer.apple.com/reference/uikit/uiviewcontroller) — это объект, отвечающий за представление экрана нашего приложения (о более сложных применениях вы узнаете в одной из тем курса). У вью-контроллера есть указатель на [`UIView`]() — объект, который описывает контент определенной области экрана. Внутрь одной вьюшки могут добавляться другие — получается иерархическая структура.

Нам нужно добавить элементы интерфейса внутрь нашего вью-контроллера. Начнем с текстового лейбла, который будет отображать название компании. Для этого:

1. Найдем компонент `UILabel` в библиотеке объектов (Object Library) и перетащим его в левый верхний угол нашего вью-контроллера;
2. При помощи механизма Auto Layout (Тут будет полезно погуглить, что это такое. Например, [статья от Рея](https://www.raywenderlich.com/811496-auto-layout-tutorial-in-ios-getting-started)) привяжем его к левому краю вьюхи так, чтобы слева и сверху от лейбла оставалось по 40 пойнтов:
    1. Выберем только что добавленный лейбл на экране;
    2. Добавим ему два *констрейнта*, зафиксировав отступ слева и сверху от границ вьюхи. Для этого вызовем панель добавления констрейнтов (см. скриншот) и укажем величину отступов в ней (40 пт). Обратите внимание на изображенные красным цветом иконки констрейнтов — активны будут только сплошные (!).

![](https://user-images.githubusercontent.com/4648742/131659622-b7d299a7-0a87-4164-a354-aafd06ddb590.png)

3. Аналогичным образом добавим еще один лейбл — на этот раз в правый верхний угол;
4. Изменим текст левого лейбла на “Company name,” а правого — на “—.”
5. По умолчанию тексты в лейблах привязаны к левому краю. Мы же хотим в правом лейбле выставить выравнивание по правому краю. Для этого, выделив правый лейбл, в панеле инспектора атрибутов выставим соответствующий вариант alignment.

![](https://user-images.githubusercontent.com/4648742/131659850-02dfa73f-d5e9-4dd5-b0b8-7948c7f38be4.png)

В результате получим следующее:

![](https://user-images.githubusercontent.com/4648742/131659919-e839d174-96ca-4ec7-b3b0-a3faa4f26fc6.png)

6. Сейчас добавленные элементы интерфейса будут отображаться на экране, но мы не сможем взаимодействовать с ними из кода — например, заменить “company name” на реальное название компании. Для связи интерфейса с кодом используются *аутлеты* (`@IBOutlet`). Добавим их:
    1. Нам нужно видеть сториборд и код вью-контроллера одновременно, рядом друг с другом. Для этого откроем сториборд, а затем, удерживая <kbd>⌥</kbd>, выберем файл `ViewController.swift` — последний должен открыться справа от сториборда;
    2. Выделим лейбл и, удерживая <kbd>⌃</kbd>, перетащим его в код:

![](https://user-images.githubusercontent.com/4648742/131661151-00c5775f-7a33-4b42-9e0d-ee4ffdcc625a.png)

    3. Когда вы отпустите элемент, появится окно создания аутлета. Введите в нем название лейбла, а остальные параметры оставьте без изменений:

![](https://user-images.githubusercontent.com/4648742/131661183-984a4f70-43e8-4205-affc-90f486d59279.png)

Теперь к лейблу можно обращаться из кода по названию `companyNameLabel`.

Попробуем собрать наш проект в симуляторе. Нажимаем <kbd>⌘</kbd> + <kbd>R</kbd> и некоторое время ждем, пока Xcode выполнит необходимые шаги. Через некоторое время запустится симулятор, и мы увидим экран нашего приложения с двумя лейблами.

![](https://user-images.githubusercontent.com/4648742/131661477-339dff0f-fa2d-4230-9702-43b8ded75096.png)

Теперь для того, чтобы отобразить название компании, нам нужно обратиться к нашему лейблу внутри вью-контроллера и задать ему текст: например, “Tinkoff.” Выберем в проектном навигаторе файл `ViewController.swift` и в методе `viewDidLoad()` (он вызывается, когда экран загружен в память и все контролы на нем созданы) установим строку текста свойству `text` нашему `companyNameLabel`:

![](https://user-images.githubusercontent.com/4648742/131668858-935fe1b1-97ba-4be5-aeca-a62af251f8c3.png)

Итак, мы разобрались с тем, как элементы интерфейса «прокидываются» во вью-контроллер. Дальше нужно добавить *пикер* для выбора компании и индикатор активности для того, чтобы пользователь видел, когда приложение выполняет запросы к сети. Начнем с пикера:

1. Найдем компонент `UIPicker` в библиотеке объектов (Object Library) и перетащим его в наш вью-контроллер. Расположим его в нижней части экрана;
2. Привяжем наш пикер к границам экрана снизу, слева и справа. Сделать это можно через панель добавления констрейнтов:

![](https://user-images.githubusercontent.com/4648742/131669074-5e040bcf-feca-4c52-b503-7834ed62c153.png)

3. Высоту пикера зададим равной 30% от высоты вьюшки. Для этого нужно выбрать пикер, затем, удерживая <kbd>⌃</kbd>, провести мышкой от пикера к вью и, наконец, выбрать опцию Equal Heights.

![](https://user-images.githubusercontent.com/4648742/131669295-aad4fa3d-def4-4438-8a9c-c68878ff5944.png)

4. Сейчас высоты равны друг другу. Поскольку мы хотим выставить соотношение 30%, нам нужно поменять мультипликатор констрейнта с 1 на 0.3. Откройте Size Inspector, выберите констрейнт, нажмите Edit и введите нужное значение:

![](https://user-images.githubusercontent.com/4648742/131669477-64826b8f-e4f1-484e-a4b2-90c5b4a168d3.png)

После повторного запуска приложения вы увидите экран приложения с пустым пикером:

![](https://user-images.githubusercontent.com/4648742/131669543-7b4a4baa-ba4f-4eb1-b2e9-81045439c362.png)

5. Теперь нужно по аналогии с лейблом создать аутлет для пикера — `companyPickerView`:

![](https://user-images.githubusercontent.com/4648742/131669665-c98b6952-5095-4c90-9c41-23bff97d23c9.png)

![](https://user-images.githubusercontent.com/4648742/131669702-397e6fed-603f-4986-b6f4-f316768a8390.png)

Осталось добавить индикатор загрузки:

1. Найдем компонент `UIActivityIndicator` в библиотеке объектов (Object Library) и перетащим его в наш вью-контроллер. Расположим его по центру вьюхи. Индикатор будет отображаться только тогда, когда у нас еще нет информации для выбранной ценной бумаги. И наоборот, когда информация загружена — индикатор будет скрыт;
2. Привяжем наш индикатор активности к центру экрана, добавив ему констрейнты выравнивания в контейнере в середине вертикальной и горизонтальной осей:

![](https://user-images.githubusercontent.com/4648742/131669863-2d3d89fe-4042-43da-a8fd-fd038713e03b.png)

3. Добавим аутлет `activityIndicator` так же, как делали это раньше.

В коде вью-контроллера должно быть три аутлета:

![](https://user-images.githubusercontent.com/4648742/131669963-492d7ab0-99c6-4ff8-b9af-81da66dfdfb0.png)

К текущему моменту у нас есть нужные компоненты интерфейса и возможность взаимодействовать с ними из кода. Но список компаний пока пустой. Давайте наполним пикер названиями компаний, чтобы у пользователя был выбор.

## Выбор компании

Наш пикер реализован классом `UIPickerView`. Он спроектирован так, что для наполнения пикера данными необходимо указать объект, который бы этим данные ему предоставил. Такой объект называется `dataSource`, для корректной работы он должен реализовывать протокол `UIPickerViewDataSource`, который состоит из следующих методов:

* `numberOfComponents(in: UIPickerView) -> Int` возвращает количество компонентов в пикере. Нам будет достаточно одного — для названия компании. В других ситуациях их может быть больше (вспомните настройку времени будильника);
* `pickerView(_: UIPickerView, numberOfRowsInComponent: Int) -> Int` показывает, сколько вариантов можно выбрать в каждом из компонентов.

Для начала нам нужно создать *словарь* (`Dictionary`) со списком компаний, которые мы предложим пользователю. Ключами словаря будут отображаемые в пикере названия компаний, а значениями — тикеры. Начнем с простого словаря из нескольких компаний:

![](https://user-images.githubusercontent.com/4648742/131671145-568b4ce5-f999-4e6d-87b5-dc2b606ab04d.png)

У нас фиксированное количество компаний, поэтому нам не составит труда сообщить эту информацию пикеру.

1. Объявим, что наш `ViewController` реализует протокол `UIPickerViewDataSource`:

![](https://user-images.githubusercontent.com/4648742/131671271-cdca7ee0-de7f-404e-95d2-154804944f00.png)

2. Добавим реализацию необходимых методов:

![](https://user-images.githubusercontent.com/4648742/131671299-44622c9e-6dae-4847-acab-db51e32ade11.png)

3. Установим `dataSource` пикера, чтобы он знал, у кого запрашивать данные:

![](https://user-images.githubusercontent.com/4648742/131671351-85487794-eef1-4d36-94f0-b5ceaa228953.png)

Сейчас пикер может узнать количество компаний, но как именно их нужно отображать, он не знает. Для решения этой задачи используется другой протокол — `UIPickerViewDelegate`, — через который пикер получает названия элементов.

1. Объявляем, что `ViewController` реализует `UIPickerViewDelegate`:

![](https://user-images.githubusercontent.com/4648742/131671607-1a4cadfd-3529-48aa-af1b-cf4467b31056.png)

2. Добавляем реализацию метода, который возвращает название варианта по его индексу (`row`). В нашем случае это соответствующий индексу ключ словаря `companies`:

![](https://user-images.githubusercontent.com/4648742/131671697-b0b5fa75-8b8f-44c7-8eb8-65690ab152bb.png)

3. Устанавливаем `delegate` пикера:

![](https://user-images.githubusercontent.com/4648742/131671733-f398149e-6a2b-43b7-ab51-8bb646f545b8.png)

Попробуем запустить приложение. Если мы все сделали правильно, пикер наполнится вариантами:

![](https://user-images.githubusercontent.com/4648742/131671804-4558d352-71ca-440e-9fd3-c095921f9337.png)

## Получение данных от сервиса

Сейчас пользователь может выбрать компанию из списка, но конкретные данные по ней по ней отображаться не будут — для этого нужно получить их из сети.

Нам нужно написать метод, который будет отправлять HTTP-запросы на адрес `https://cloud.iexapis.com/stable/stock/{symbol}/quote` (вместо `symbol` должен подставляться тикер компании), получать ответ от сервера и выбирать из него нужные поля — название компании и другую информацию для отображения. Начнем с запроса данных из сети.

Воспользуемся объектом [`URLSession`](https://developer.apple.com/reference/foundation/urlsession) для загрузки данных: создадим с его помощью задачу загрузки данных ([`URLSessionDataTask`](https://developer.apple.com/reference/foundation/URLSessionDataTask)), сконфигурировав и передав нужный URL. Полученную задачу запустим на выполнение:

![](https://user-images.githubusercontent.com/4648742/131672503-57b2c92d-ff68-41bf-b041-410717e3d7e6.png)

Проверим, что запрос выполняется. Запустим анимацию `UIActivityIndicatorView` и вызовем метод `requestQuote(for:)` после загрузки вью-контроллера:

![](https://user-images.githubusercontent.com/4648742/131672572-745c3a1d-1e80-41ce-9c42-b8f7b9b34b83.png)

Самый простой способ посмотреть, как выполнился запрос, — поставить брейкпойнт на строку `print(data!)` в методе `requestQuote(for:)`. Когда приложение дойдет до этого места в коде, оно поставится на паузу и позволит нам проинспектировать содержимое `data`.

![](https://user-images.githubusercontent.com/4648742/131672642-9db6c489-29ed-4fd0-986d-62d49f950f81.png)

Теперь, когда мы получаем ответ и в `data` что-то есть, перейдем к реализации метода парсинга: попробуем из полученного объекта достать JSON-объект, а уже из него — информацию о выбранной пользователем компании. Если ответ был невалидным, выведем сообщение в консоль. В дальнейшем будет круто сделать отображение ошибок в интерфейсе в виде алерта (или иным способом).

![](https://user-images.githubusercontent.com/4648742/131672963-d3d18517-bad3-4219-a0d3-5e3643ef8900.png)

Воспользуемся стандартным `JSONSerialization` и его методом `jsonObject(with:options:)`. Метод может выкинуть исключение, поэтому обернем его в `do–try–catch`. В случае успешного получения JSON-объекта необходимо по ключу `companyName` найти в словаре название компании:

![](https://user-images.githubusercontent.com/4648742/131673107-62ddb6a3-74b8-40c3-99c3-52ebd541772a.png)

Итак, у нас есть метод, который парсит `Data` из ответа запроса и вытаскивает из JSON название компании, которое можно передать в наш лейбл.

Создадим отдельный метод для обновления информации об акции на экране. В качестве параметров пока будем передавать только название компании. Так же в этом методе будем останавливать анимацию `activityIndicator`. Обратите внимание, что загрузка данных осуществлялась на фоновом потоке, при этом работа с интерфейсом **всегда** должна происходить на главном. Чтобы переключиться на главный поток, нужно обернуть код в специальную конструкцию `DispatchQueue.main`.

![](https://user-images.githubusercontent.com/4648742/131673317-281c26e4-a918-44b9-ae9d-6566f03743f7.png)

Один нюанс: у нас отображается индикатор загрузки, но он отображается всегда — даже когда не вращается. Давайте настроим его так, чтобы он отображался только во время анимации:

![](https://user-images.githubusercontent.com/4648742/131673414-2c43a93e-ee64-4444-bd1b-a67047774e4e.png)

Как можно заметить, название компании, отображающийся в лейбле, не совпадает с выбранной в пикере. Даже если выбрать другую компанию, ничего не изменится. Нам нужно обрабатывать выбор пользователя и выполнять новый запрос, когда выбор изменился.

## Взаимодействие с пользователем

Протокол `UIPickerViewDelegate` также позволяет реализовать метод `pickerView(_:didSelectRow:inComponent:)`, который будет вызван пикером при изменении выбранного элемента.

Реализуем этот метод, перенеся выполнение запроса по выбранной валюте в него (уберем его из `viewDidLoad()` и подставим в качестве параметра значение из словаря `companies`, соответствующее выбранному элементу пикера):

![](https://user-images.githubusercontent.com/4648742/131653440-b40907eb-8717-444e-93da-a11c3a072fcd.png)

Теперь можно выбирать разные акции и получать название компании для них.

Если переключать пикер, информация загружается. Но нам хочется, чтобы на старте приложения по выбранной акции запрос выполнялся сразу. Для этого напишем метод обновления, в который вынесем из делегатного метода логику выполнения запроса, заменив ее вызовом этого метода:

![](https://user-images.githubusercontent.com/4648742/131653429-a179ed46-0e31-4e13-a0e6-68fa4904f056.png)

Будем вызывать его и после загрузки контроллера:

![](https://user-images.githubusercontent.com/4648742/131653411-aa17ad07-e129-4c75-877d-193b80cba19a.png)

Теперь после старта приложения мы сразу видим название компании выбранной акции:

![](https://user-images.githubusercontent.com/4648742/131653382-6464ffdf-8d80-4b85-a754-f17298df9881.png)

Сделаем так, чтобы текст в лейбле сбрасывался на “—” во время загрузки данных.

![](https://user-images.githubusercontent.com/4648742/131653334-871c9b70-16c7-40cd-9c72-ab140809b0e2.png)

Далее, по аналогии с названием компании, нам нужно добавить лейблы для отображения тикера акции, текущей цены и ее изменения. Добавим лейблы на нашу вьюшку в `Main.storyboard` и настроим *констрейнты* Auto Layout (все отступы на скриншоте по 40 пойнтов):

![](https://user-images.githubusercontent.com/4648742/131653318-d1acd8d5-93bb-4f6c-9017-1db132c2b072.png)

Привяжем три лейбла, в которых будет отображаться информация, к классу `ViewController`, добавив аутлеты:

![](https://user-images.githubusercontent.com/4648742/131653289-b7934ac3-ee16-4d70-b060-ace21cce0bf1.png)

Добавим сброс текста в лейблах в метод `requestQuoteUpdate()`:

![](https://user-images.githubusercontent.com/4648742/131653272-617d62c4-557b-46a0-a029-bf9373f582a7.png)

Обновим код парсинга и метод отображения информации на экране:

![](https://user-images.githubusercontent.com/4648742/131653237-ee536e99-f3e1-404b-adc2-27f53a59e5e0.png)

В результате должно получиться следующее:

![](https://user-images.githubusercontent.com/4648742/131653154-38e444d5-43a2-4145-99bf-9407c8977adf.png)

В текущем состоянии приложение работает и им можно пользоваться — оно решает поставленную задачу. Но, безусловно, в нем еще много можно улучшить.

## Что можно улучшить

То, что у вас получилось к текущему моменту, — лишь самое начало. У вас есть еще много возможностей доработать приложение и продемонстрировать, на что вы способны. Не упускайте их!

С чего можно начать:

* Добавить изменение цвета текста лейбла `priceChangeLabel` в зависимости от того, в какую сторону изменилась цена акции: если цена выросла, лейбл красится в зеленый цвет, если упала — в красный, если не изменилась — лейбл остается черным. Изменять цвет текста можно, передав новый цвет в свойство `textColor` объекта класса `UILabel`. Обратите внимание, что при сбросе лейбла в методе `requestQuoteUpdate()` следует изменить цвет текста на черный.
* В использованном нами API есть возможность получить ссылку на логотип компании методом `/stock/{symbol}/logo`, который возвращает URL на картинку вида `https://storage.googleapis.com/iex/api/logos/{symbol}.png`. Можно скачать по нему логотип и отобразить его на экране с помощью `UIImage`. (Загрузка картинки не должна блокировать взаимодействие с приложением!)
* На данный момент доступные акции «захардкожены» в приложении. Было бы намного удобнее, если бы приложение формировало список акций динамически: например, по запросу `/stock/market/list/gainers`. Во-первых, было бы больше акций, а во-вторых, они бы обновлялись без переустановки приложения. (Не забудьте обработать кейс старта приложения в момент, когда нет связи с интернетом.)
* В текущей реализации не вполне понятно назначение приложения. Возможно, вы знаете, как сделать интерфейс более интересным и привлекательным. Попробуйте доработать интерфейс по своему усмотрению — здесь нет правильных и неправильных решений.
* Если приложение не подключено к интернету или сервер не ответил на запрос, приложение не сможет отобразить информацию. Подобные нештатные ситуации нужно обрабатывать, чтобы пользователь не ломал голову. Реализуйте отображение алерта (`UIAlertController`) с ошибкой.

Выполнение данных пунктов увеличивает ваши шансы на поступление. По статистике зачисленные на курс студенты выполняли все или несколько из описанных улучшений.

## Чеклист перед сдачей работы

* [ ] Проверить соответствие работы требованиям в задании
* [ ] Хотя бы попробовать сделать дополнительные пункты из задания
* [ ] Убедиться, что все файлы закомичены
* [ ] Запушить комиты на GitHub — проверить, что они отображаются на сайте
* [ ] Повторно клонировать репозиторий в отдельную папку и собрать проект из нее — убедиться, что все запускается и работает как надо
* [ ] Отправить ссылку на репозиторий

Желаем успехов!
